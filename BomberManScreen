package cs2114.bomberman;

import sofia.graphics.Color;
import java.util.ArrayList;
import sofia.graphics.OvalShape;
import sofia.app.ShapeScreen;
import cs2114.bomberman.BoardCell.CellTypes;

// -------------------------------------------------------------------------
/**
 * Creates a ShapeScreen with tile objects in a 7x11 grid. Responds to touch
 * events and displays a new level when appropriate.
 * @author crc1559
 * @author aaronk1
 * @author zhinson
 * @version Nov 13, 2013
 */
public class BomberManScreen extends ShapeScreen
{
    private Tile[][] grid;
    private Tile tempTile; //can be used anywhere for temporary storage
    private Board board;
    private BomberMan bomberman;
    private ArrayList<Enemy> enemies;
    private ArrayList<OvalShape> cpus;
    private OvalShape player; //temporary placeholder for actual images
    private int numEnemies = 1;

    public void initialize()
    {
        grid = new Tile[7][11];
        board = new Board();
        float cellWidth = getWidth()/7;
        float cellHeight = getHeight()/11;
        for (int i = 0; i < 7; i++)
        {
            for (int k = 0; k < 11; k++)
            {
                Location loc = new Location(i, k);
                Tile tile =
                    new Tile(i * cellWidth, k * cellHeight, (i + 1) * cellWidth,
                        (k + 1) * cellHeight, loc);
                add(tile);
                grid[i][k] = tile;
            }
        }
        /*improve some of the coloring, adds a white border to each tile for
              visual clarity and sets fill colors acording to CellType
          NOTE: setColor sets the border color
          NOTE: setFillColor sets the color of the tile minus the border
              if setFillColor is called without setColor, the border will be the
              color of the fill
        */
        for (int i = 0; i < 7; i++)
        {
            for (int j = 0; j < 11; j++)
            {
                tempTile = grid[i][j];
                tempTile.setColor(Color.white);
                if (board.getCell(tempTile.getCoord()) == CellTypes.DEBRIS)
                {
                    tempTile.setFillColor(Color.lightSlateGray);
                }
                else if ((board.getCell(tempTile.getCoord()) == CellTypes.WALL))
                {
                    tempTile.setFillColor(Color.darkSlateGray);
                }
                else if ((board.getCell(tempTile.getCoord()) == CellTypes.PATH))
                {
                    tempTile.setFillColor(Color.rgb(0, 160, 0));
                }
            }
        }
        //add bomberman (the player) to the screen
        bomberman = new BomberMan();
        tempTile = grid[0][0];
        player = new OvalShape(tempTile.getCenterPointX(),
            tempTile.getCenterPointY(), 20);
        player.setFillColor(Color.blue);
        add(player);

        //add the enemies, currently only supports up to 4, will get
        //errors otherwise
        enemies = new ArrayList<Enemy>();
        cpus = new ArrayList<OvalShape>();
        for (int i = 0; i < numEnemies; i++)
        {
            Enemy tempEnemy = new Enemy(new Location(3, (i + 1) * 2), board);
            tempTile = grid[3][(i + 1) * 2];
            enemies.add(tempEnemy);
            cpus.add(new OvalShape(tempTile.getCenterPointX(),
                        tempTile.getCenterPointY(), 20));
            cpus.get(i).setFillColor(Color.red);
            add(cpus.get(i));
        }
    }

    /**
     * is called when the player presses the screen. Handles all movement and
     * actions of the visual game.
     * @param x coordinate of pixel
     * @param y coordinate of pixel
     */
    public void onTouchDown(float x, float y)
    {
        boolean occupied = false;
        Tile tile =
            getShapes().locatedAt(x, y).withClass(Tile.class).front();
        //Step 1: Move bomberman. His action comes first.
        Location locbomberman = bomberman.getCoord();
        int tilex = tile.getCoord().x();
        int tiley = tile.getCoord().y();
        int bomberx = locbomberman.x();
        int bombery = locbomberman.y();
        for (Enemy enem : enemies)
        {
            if (enem.getLocation().x() == tilex
                && enem.getLocation().y() == tiley)
            {
                occupied = true;
                //cut out of the for early if the location is occupied
                break;
            }
        }
        if (board.getCell(tile.getCoord()) == CellTypes.PATH && !occupied)
        {
            if (tilex == bomberx && tiley == bombery + 1)
            {
                bomberman.moveDown();
                player.setPosition(tile.getCenterPointX(), tile.getCenterPointY());
            }
            else if (tilex == bomberx && tiley == bombery - 1)
            {
                bomberman.moveUp();
                player.setPosition(tile.getCenterPointX(), tile.getCenterPointY());
            }
            else if (tilex == bomberx + 1 && tiley == bombery)
            {
                bomberman.moveRight();
                player.setPosition(tile.getCenterPointX(), tile.getCenterPointY());
            }
            else if (tilex == bomberx - 1 && tiley == bombery)
            {
                bomberman.moveLeft();
                player.setPosition(tile.getCenterPointX(), tile.getCenterPointY());
            }
        }

        //Step 2: Have the enemies act
        for (Enemy enem : enemies)
        {
            int i = 0;
            Location loc = enem.action();
            //this null check is temporary until action() is changed so that it
            //can never return null
            if (loc != null)
            {
                tempTile = grid[loc.x()][loc.y()];
                //TODO: place a bomb if location is original location before action
                cpus.get(i).setPosition(tempTile.getCenterPointX(),
                    tempTile.getCenterPointY());
            }
            i++;
        }

        //Step 3: Bombs decrease in time or go off

        //TODO: do bomb work, includes powerup placement and updating number
        //of enemies. Also should handle loss of game.

        //Step 4: update the board for the enemies assuming the game wasn't lost
        for (Enemy enem : enemies)
        {
            enem.updateBoard(board);
        }
    }

}
